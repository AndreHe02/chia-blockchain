(mod (mod-hash                ;; curried in
      ancestry            ;; curried into puzzle
      spender              ;; spender public key, determines level of control
      receivers
      amounts
      prev-coin        ;; used in this coin's announcement, prev-coin ASSERT_COIN_ANNOUNCEMENT will fail if wrong
      this-coin        ;; verified with ASSERT_MY_COIN_ID
      next-coin        ;; used to generate ASSERT_COIN_ANNOUNCEMENT
      prev-subtotal           ;; included in announcement, prev-coin ASSERT_COIN_ANNOUNCEMENT will fail if wrong
    )

     ;;;;; start library code
     ;;;;; remember to restore this
     ;;;;; end library code


     ;;;;; OUTPUT VALUE FOR CONDITION ;;;;;
     (defun-inline output-value-for-condition (condition)
       (if (= (f condition) CREATE_COIN)
         (f (r (r condition)))
         0
       )
     )

     ;;;;; TOTAL OUTPUT VALUE FOR A LIST OF CONDITIONS ;;;;;
     (defun output-totals (conditions)
       (if conditions
         (+ (output-value-for-condition (f conditions)) (output-totals (r conditions)))
         0
       )
     )

     ;; ID OF A COIN TRIPLET
     (defun coin-id-for-coin ((parent-id puzzle-hash amount))
       (sha256 parent-id puzzle-hash amount)
     )

     ;; utility to fetch coin amount from coin
     (defun-inline input-amount-for-coin (coin)
       (f (r (r coin)))
     )

     (defun-inline puzzle-hash-for-coin (coin)
        (f (r coin))
     )


     ;;;;;;;;;;;;;;;;;;;;;;;

     (defun hc-puzzle-hash ((mod-hash mod-hash-hash ancestry ancestry-hash)))
        (sha256tree_esc (curry mod-hash mod-hash-hash ancestry-hash)
                mod-hash
                mod-hash-hash
                ancestry-hash
        )
     )

     (defun is-coin-valid (coin hc-hash)
       (= (puzzle-hash-for-coin coin) hc-hash)
     )

     (defun make-create-coin-condition (mod-hash ancestry amount)
        (list   CREATE_COIN
                (hc-puzzle-hash (list mod-hash (sha256tree1 mod-hash) ancestry (sha256tree1 ancestry)))
                amount)
     )

     (defun make-create-coin-conditions (mod-hash ancestries amounts)
        (if ancestries
            (c
                (make-create-coin-condition mod-hash (f ancestries) (f amounts))
                (make-create-coin-conditions mod-hash (r ancestries) (r amounts))
            )
            ()
        )
     )

     (defun make-receiver-ancestries (spender-ancestry receivers)
        (if receivers
            (c
                (c (f receivers) spender-ancestry)
                (receiver-ancestries spender-ancestry (r receivers))
            )
            ()
        )
     )

     (defun x-if-x-else-y (x y)
        (if x x y)
     )

     ; assume no horizontal transfer for now
     (defun find-spender-ancestry (ancestry spender)
        (if ancestry
            (if (= (f ancestry) spender)
                ; take the shorter ancestry if a spender is repeated
                (x-if-x-else-y
                    (find-spender-ancestry (r ancestry) spender)
                    ancestry
                )
                (find-spender-ancestry (r ancestry) spender)
            )
            ()
        )
     )

     (defun generate-conditions (mod-hash ancestry spender receivers amounts)
        (make-create-coin-conditions
            mod-hash
            (make-receiver-ancestries
                (x-if-x-else-y
                    (find-spender-ancestry ancestry spender)
                    (x "invalid spender")
                )
                receivers)
            amounts)
     )

     (defun-inline create-assert-my-id (this-coin-info)
       (list ASSERT_MY_COIN_ID (coin-id-for-coin this-coin-info))
     )

     ;; calculate the hash of an announcement
     (defun-inline calculate-annoucement-id (this-coin-info this-subtotal next-coin-info)
       ; NOTE: the next line containts a bug, as sha256tree1 ignores `this-subtotal`
       (sha256 (coin-id-for-coin next-coin-info) (sha256tree1 (list this-coin-info this-subtotal)))
     )

     ;; create the `ASSERT_COIN_ANNOUNCEMENT` condition that ensures the next coin's announcement is correct
     (defun-inline create-assert-next-announcement-condition (this-coin-info this-subtotal next-coin-info)
       (list ASSERT_COIN_ANNOUNCEMENT
             (calculate-annoucement-id this-coin-info
                                            this-subtotal
                                            next-coin-info
             )
       )
     )

     ;; here we commit to I_{k-1} and S_k
     (defun-inline create-announcement-condition (prev-coin-info prev-subtotal)
       (list CREATE_COIN_ANNOUNCEMENT
             (sha256tree1 (list prev-coin-info prev-subtotal))
       )
      )

     (defun-inline create-assert-signature (spender receivers amounts)
        (list   AGG_SIG_ME
                spender
                (sha256tree1 (list receivers amounts))
        )
     )

     (defun-inline generate-final-output-conditions
       (
         prev-subtotal
         this-subtotal
         conditions
         prev-coin
         this-coin
         next-coin
         spender    ;; spender needs to sign receivers and amounts
         receivers
         amounts
       )
       (c (create-assert-signature spender receivers amounts)
           (c (create-assert-my-id this-coin)
             (c (create-announcement-condition prev-coin prev-subtotal)
               (c (create-assert-next-announcement-condition this-coin this-subtotal next-coin)
                 conditions)
             )
           )
        )
      )

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;

     (defun main (
         mod-hash
         ancestry
         spender
         receivers
         amounts
         conditions
         hc-hash
         prev-coin
         this-coin
         next-coin
         prev-subtotal
      )
      (assert

        (is-coin-valid prev-coin hc-hash)

        (is-coin-valid this-coin hc-hash)

        (is-coin-valid next-coin hc-hash)

        (generate-final-output-conditions
            prev-subtotal
            (+ prev-subtotal (- (input-amount-for-coin this-coin) (output-totals conditions)))
            conditions
            prev-coin
            this-coin
            next-coin
            receivers
            amounts
        )
      )
    )

    (main
        mod-hash
        ancestry
        spender
        receivers
        amounts
        (generate-conditions mod-hash ancestry spender receivers amounts)
        (hc-puzzle-hash (list mod-hash (sha256tree1 mod-hash) ancestry (sha256tree1 ancestry)))
        prev-coin
        this-coin
        next-coin
        prev-subtotal
    )
)
